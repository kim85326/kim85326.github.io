---
layout: post
title: "CH1 OS在幹嘛"
date: 2017-11-11 00:00:00 +0800
categories: 作業系統
tags: OS 作業系統
excerpt: .
mathjax: true
---

### 當硬體複雜到一個程度的時候，必須有個媒介來控制 **OS**
1. 可以讓我們更容易解決問題
2. 可以讓PC的介面更容易使用
3. 讓硬體更有效率的使用

### 電腦可以被切成四塊
1. 硬體:
    * CPU, memory, I/O devices
2. OS
3. Application programs (APP)
4. Users
    * People, machines, other computers

### OS 是 resource allocator
是資源分配者，會以有效率且公平的方式來管理與分配系統resource(硬體)。


### OS 是 control program
監督使用者程式的執行，避免程式發生錯誤或使用不當(防止惡意程式毀滅系統)。


### OS的定義
1. 對於OS 並沒有一個完整適合的定義
2. 通常我們把管理硬體有關的program都稱為OS
"Everything a vendor ships when you order an
operating system"
3. OS 是使用者與硬體的介面，做為電腦系統資源的管理者，以有效的管理方式來使用硬體，提供使用者可執行程式的環境。

### kernel的定義
1. 只要開機就會一直被執行的program
"The one program running at all times on the
computer"
其他是系統程式(system program)或 app

2. 核心就是系統上面的一個檔案而已，這個檔案包含了驅動主機各項硬體的偵測程式與驅動模組

### bootstrap program
1. 在開機或重開機的時候會讀取的程式
    * 通常放在ROM或EEPROM裡，被稱為韌體(firmware)
        (資料不會隨著電源消失而消失的RAM)
        * 開機後OS 會偵測系統的週邊設備，逐一載入每一種設備的驅動程式
    * 開機程式的作用
        1. 設定系統初值或參數，包括CPU registers、device controllers、memory等等
        2. 從硬碟將作業系統核心載入記憶體
        3. 啟動os的執行
            * 啟動OS 後所執行的第一個process 稱為init，init 會產生許多幕後的login process 在那兒等候事件的發生，完成開機的程序


### Computer-system operation (計算機系統的運作)
I/O和CPU經由公用Bus(匯流排)存取共用Memory

![](https://i.imgur.com/UxS2vCN.png)
1. I/O和CPU可以同時在運作
2. 每個I/O device都有一個controller在負責控制，同時擁有local buffer
3. device controller 需要專屬軟體來指揮它們，這些軟體叫做驅動程式(device driver)
    * 驅動程式對controller 下命令指揮它們完成輸出入工作
    * OS 透過driver 來控制與指揮device controller 對週邊設備做實際的I/O 動作
4. CPU從memory裡拿出資料放到local buffer
或從local buffer拿出資料放到memory裡
5. device controller利用中斷(inperrupt)來通知CPU，他做好I/O了

* Should device controller be consider as a CPU?
    =>Many I/O device even have powerful microprocessor

### I/O做完要怎麼通知CPU?
1. polling: 用一個while loop一直戳device controller，看他做完了沒
    => 相當浪費時間
2. interrupt
    => 優點 不用polling，一直戳很浪費時間
    => 缺點 要額外的軟體、硬體來做interrupt
    
### Interrupt在幹嘛?
1. 當I/O device完成動作後，他會朝CPU打出interrput，interrupt裡面含有中斷服務程式的地址
2. Interrupt architecture會把這個中斷服務程式的地址存下來，並且執行這個中斷服務程式(ex. 處理I/O拿進來的資料)
3. 如果在執行中斷處理的同時有另一個interrupt打進來，這個interrupt是無效的
4. CPU正在忙剛剛的I/O，沒有時間做新的I/O
5. 避免錯失interrupt

### Interrupt 處理
中斷發生時，硬體將被中斷程式的暫存器以及return address 儲存在一個固定位置上，以便將來能夠恢復原來的執行工作。

1. 暫停目前 process 執行並保存此process 當時執行狀況
2. 立即移轉到固定的記憶體位置上(根據 Interrupt ID 查尋)，此位置含有interrupt vector
3. interrupt vector 儲存ISR (Interrupt Service Routine)的起始位址
4. CPU 根據這個位址去執行相關的服務工作
5. 執行完成，恢復先前 process 執行狀況回到原先中斷前的執行



### Interrupt的種類:
1. 硬體打進來的叫IRQ
2. 軟體打進來的叫Trap or exception，是經由system call 產生的中斷。包括邏輯錯誤，不合法的記憶體存取
    * 常見的trap
        * divide-by-zero
        * invalid memory access
        * illegal instruction
        * a request for OS service
3. OS是一個中斷驅動(interrupt driver)

### Interrupt timeline
CPU 與I/O 可同時進行，CPU 啟動I/O 動作，I/O 完成後會發出中斷給CPU。

![](https://i.imgur.com/nHkmWMK.png)

### I/O 架構(structure)
1. 同步 I/O 架構 (Synchronous)：一段時間內只有一個 I/O 請求產生。
2. 非同步 I/O 架構 (Asynchronous)：必須有一個Device-status table以記錄各種裝置 I/O 的類型、位址、使用狀況。

### 直接存取記憶體 Direct Memory Access Structure
DMA 是一種專門為high speed devices 做輸出入的設備 (沒有CPU的介入會變快)

* 作業程序
    1. 首先由CPU預設好I/O所需要的buffer、pointer與counter後
    2. 由CPU啟動DMA controller，讓DMA 自行去做記憶體與buffer之間的大量資料讀寫的工作，而不用CPU的干預
    3. 每當讀寫完一筆資料後，才由DMA controller發出中斷告訴CPU工作已完成
    4. 接著再由CPU重新設定buffer、pointer與counter
    5. 繼續啟動DMA做後續的輸出入工作

* 一個block產生一個中斷，不像其他是一個byte就產生一個中斷

### Storage Structure
1. 任何要被執行的程式都必須儲存在可複寫記憶體，稱之為主記憶體，又稱隨機存取記憶體 (Random-Access Memory或RAM)
以動態隨機存取記憶體(DRAM: Dynamic RAM)的半導體技術製作而成
(volatile揮發性)

2. 大部份電腦系統提供輔助記憶體 ( secondary storage) 做為主記憶體的延伸
輔助記憶體的主要要求是能夠永久保存大量的資料
(nonvolatile非揮發性)

3. 磁碟(Magnetic disks)
4. 固態硬碟(Solid-state disks)

### 記憶體的階層
1. Speed
2. Cost
3. Volatility (電源切了就掰了)
4. caching: 將讀過的東西(比較常使用的意味)放在比較快的storage裡 
    => 快
    => cache很容易滿
5. buffer: 在短時間內寫入多次 
    => 放入buffer裡面一次做完I/O

![](https://i.imgur.com/5TJoDsG.png)

### 快取 (Caching)
Cache 又稱為buffer memory 是一種成本高且速度快的儲存設備。
1. CPU 欲讀取資料會先檢查資料是否在cache
2. 若是稱之為hit，可立即取出使用；否則稱之為no hit
3. 必須到記憶體取出資料同時更新cache 的內容。

### 電腦系統架構 (Computer-System Architecture)
1. 單一處理器系統(Single-Processor Systems)
    * 僅有一個一般處理器執行使用者的處理行程之系統。

2. 多處理器系統(Multiprocessors)
又稱 並連系統(parallel systems)、耦合系統(tightly-coupled systems)
    * 擁有一個以上的處理器，共同使用匯流排、時脈、記憶體、周邊裝置
    * 優點
        * 增加產量
        * 經濟度量(共用周邊設備)
        * 增加可信度(容錯性: Fault Tolerant)
    * 類別
        * 非對稱多元處理(Asymmetric Multiprocessing)
        * 對稱多元處理(Symmetric Multiprocessing)

![](https://i.imgur.com/BmExZDo.png)

### 對稱多元處理
1. 非對稱多元處理
    * 主處理器會指定每個處理器不同之任務，有主從關係
2. 對稱多元處理
    * 每個處理器執行相同之任務，沒有主從關係

![](https://i.imgur.com/dUxk5J8.png)

### 雙核心設計 (A Dual-Core Design)
1. UMA : 均勻訪存模型（Uniform Memory Access） 
    * 指所有的物理存儲器被均勻共享，即處理器訪問它們的時間是一樣的
2. NUMA

雙核心設計比二元處理器還有效率(內部通信)及省電。

![](https://i.imgur.com/1KiK3oI.png)

### 集成式系統 (Clustered Systems)
1. 集成式電腦分享儲存裝置，經由區域網路、無線寬頻網路彼此相連，可提供高的取得率(high-availability) 

2. 非對稱集成系統(asymmetric clustering)
一台機器處於熱待機狀態(hot-standby mode)為一監督工作的伺服器，其他機器則執行應用程式

3. 對稱集成系統(symmetric clustering)
所有機器均執行應用程式並互相監督

4. Some clusters are for high-performance computing (HPC)
     * Applications must be written to use parallelization

5. Some have distributed lock manager (DLM) to avoid conflicting 

![](https://i.imgur.com/l6ssvbo.png)

### 作業系統架構 (Operating System Structure)
* 作業系統提供執行程式的環境，工作排班的最重要觀念就是**多元程式規劃**的能力
* 多元程式規劃 (multiprogramming)的目的就是**讓CPU始終有工作做，以增加CPU的使用率**
* 作業系統在同一時間存放數項工作在記憶體中，這一組工作是工作池(job pool)中所有工作的部份集合，作業系統把工作池中的一項工作挑出來並且開始執行

#### 多元程式規劃 (Multiprogramming)是什麼?
1. 單一的User很難讓CPU和I/O一直同時保持忙碌
2. Multiporgramming收集要執行的job，讓CPU一直保持忙碌
3. memory裡面會維護一份要執行工作的清單
4. 利用Job scheduling來排程
5. 當有人在等I/O的時候CPU就可以切到下一個工作去

#### 分時(Timesharing)或多工(multitasking)是什麼?
定時打clock interrupt給CPU，讓CPU在各個process間切換，感覺同時做很多工作一樣
1. Response time < 1 sec (很短)
    * 適合user(人類)的system
2. CPU scheduling: 
    * 決定下一個job要做啥
3. Job scheduling: 
    * 決定下一個搬到memory裡的job是哪個
4. Swapping: 
    * 當main memory要爆炸了! 可以把一些job暫時放到disk裡面，等到memory比較空一點再搬回來
5. virtual memory: 
    * memory不夠了! 要執行的process太大把memory塞爆了，可以拿一些disk空間放目前沒有執行到的部分

!!! Timesharing是基於Multiprogramming，但multiprogramming不一定是time sharing!

下圖是 Memory Layout for Multiprogrammed System
![](https://i.imgur.com/Wp8ttvR.png)

### 作業系統的運作
1. 現代作業系統是中斷驅動式 (interrupt driven)，如果沒有行程要執行，沒有I/O裝置要服務和沒有使用者需要回應，則作業系統將安靜進入等待事件發生；
事件通常都是由於中斷或陷阱(Trap)的發生(如被0除)而被通知。

2. 因為作業系統和使用者共用電腦系統中硬體和軟體的資源，在共用的情況下，一個程式中的錯誤(如Infinite Loop)可能會使許多工作受到不利影響。

3. 一個設計正確的作業系統必須保證一個不正確的 (或蓄意破壞的)程式不會造成其他程式不正確的執行。

### 雙模式運作 (Dual-mode Operation)
為了確保作業系統正常操作，一定要能夠區別**作業系統程式碼**和**使用者定義程式碼**的操作。

1. 模式分兩種
    * 使用者模式 (user mode)
        * 受保護的環境，不可以直接操作硬體，不能亂打別的process，不能攻擊OS之類的
    * 核心模式 (kernel mode)
        * 也稱為 supervisor mode
        * 也稱為 系統模式(system mode)
        * 也稱為 特權模式(privileged mode)。
        * 可以做任何事!!!
    * system call可以將user mode切換至kernel mode
(以前的CPU沒有mode的概念，隨便一隻程式就可以毀滅系統)

2. 流程
    1. 在系統啟動時，硬體必須由kernel mode開始
    2. 載入作業系統
    3. 在user mode開始執行使用者應用程式
    4. 每當一個插斷或Interrupt發生時，硬體從user mode轉換到kernel mode
    5. 作業系統得到電腦的控制權時，電腦就是在kernel mode中
    6. 使用者程式再將控制權交給一個使用者程式之前，轉換到user mode

3. 越來越多的CPU支持多模式操作
    * 即虛擬機管理器（VMM）模式用於訪客虛擬機
        * virtual machine manager (VMM) mode for guest VMs 32

### 計時器 (Timer)
* 必須保證作業系統維持控制
    * 必須防止使用者程式陷入一個無窮迴路之中，而永遠不把控制權交還給作業系統。為達成此目的，可以使用一個計時器(timer)

![](https://i.imgur.com/s2TDkwr.png)

* 計時器設定在某段時間之後中斷電腦
* 其週期可以是固定的 (例如，1/60秒)或可變的(例如，從1毫秒到1秒)
* 用計時器來防止使用者程式執行太久
* 簡單的技巧是用程式允許的時間量設定計數器之初值。
* 例如: 具有 7分鐘時間限制的程式設定計數器初值為420。
* 每過 1秒鐘，計時器就會發出中斷且計數器值減 1
* 只要計數器值為正，控制權仍回到使用者程式
* 當計數器值擴成負值時
* 作業系統因為程式超過其時間限制而終止執行

### 行程管理 (Process Management)
* 行程(process)可以視為執行中的程式
    * Program is a 被動(passive) entity
    * process is an 活躍(active) entity
* 行程需要某些特定的資源，包括CPU時間、記憶體、檔案和I/O裝置等，以完成其工作，這些資源在行程產生或執行時就會配置給它
* 除了實體資源和邏輯資源的配置之外，有些起始資料 (輸入)也可能會隨著行程的產生而產生

* 行程管理方面，作業系統必須提供下列的功能:
    1. 在CPU上的行程及執行緒排班
    2. 使用者和系統行程的產生與刪除 
    3. 行程的暫停和恢復 
    4. 提供行程同步機制(process synchronization)
    5. 提供行程通信機制(process communication)
    6. 提供行程(deadlock handling)

### 主記憶體管理 (Memory Management)
memory有限，要怎麼分配?
* 程式執行時，主記憶體必須映對到絕對位址並且載入主記憶體之中
    * All data in memory before and after processing
* 程式執行時，藉由產生程式指令和資料的絕對位址，才能從記憶體存取
    * All instructions in memory in order to execute
* 程式結束時，它釋放出記憶體為可用狀態，以及載入下一個程式並且執行它。
* 主記憶體管理 (Memory Management) 決定 what is in memory when 優化(Optimizing) CPU 採用(utilization) and computer response to users

* 記憶體管理方面，作業系統必須具有下列的功能
    1. 記錄正在使用的記憶體部份以及是誰在使用
    2. 在記憶體空間可用時決定載入的行程
    3. 在需要時配置和回收記憶體空間

### 儲存體管理 (Storage Management)
* 作業系統提供資訊儲存一個一致性的邏輯觀點，目的是為了讓使用者能更方便的使用電腦系統。

* 作業系統摘取儲存裝置的實體特性並將之定義成邏輯儲存單元，也就是檔案(file)
    * 不同的屬性包括
        * 訪問速度(access speed)
        * 容量(capacity)
        * 數據傳輸速率(data-transfer rate)
        * 訪問方式(access method)順序或隨機(sequential or random)

### 檔案系統管理 (File-System Management)
1. 檔案的建立與刪除
2. 檔案的目錄(directories)建立與刪除
3. 處理(操作)檔案和目錄
4. 檔案與輔助記憶體的對映(Mapping)
5. 穩定(非揮發性non-volatile)儲存裝置上的檔案備份

### 大量儲存體管理 (Mass-Storage Management)
* 太大放不進main memory，所以放在磁盤
* 計算機操作的整體速度取決於磁盤(disk)子系統及其算法
* OS activities
    * 可用空間管理 (Free-space management)
    * 記憶體配置 (Storage allocation)
    * 磁碟排班 (Disk scheduling)
* 這些儲存的東西不需要很快
    * 三級存儲包括光纖存儲，磁帶
    * 仍然必須由os或app進行管理
    * WORM（一次寫入，多次讀取）和RW（讀寫）之間變化不大

### 快取記憶體 (Caching)

![](https://i.imgur.com/RK6fMn9.png)

### Migration of Integer A from Disk to Register
![](https://i.imgur.com/jV5BHBm.png)

### I/O Subsystem
* I/O subsystem responsible for
    * 記憶體管理構成要素包括
        * 緩衝(buffering)
        * 快取(caching)
        * 連線同時週邊作業(spooling)
    * 通用裝置驅動程式(Driver)介面
    * 特定硬體裝置驅動程式
